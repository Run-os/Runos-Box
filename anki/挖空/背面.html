<!-- 1. 强制夜间模式检测 -->
<script>
    (function () {
        var body = document.body;
        var isNight = body.classList.contains("night") || body.classList.contains("nightMode") || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);
        if (isNight) { document.documentElement.classList.add("night"); document.body.classList.add("night"); }
    })();
</script>

<!-- 2. 隐藏原始数据 -->
<div id="raw-Front" style="display:none">{{Front}}</div>
<div id="raw-Back" style="display:none">{{Back}}</div>

<!-- 3. 卡片容器 -->
<div class="minimal-card">
    <!-- 问题 -->
    <span class="label">Question</span>
    <div id="render-Front" class="content-block question-text"></div>

    <!-- 分割线 -->
    <div class="divider"></div>

    <!-- 答案 -->
    <span class="label">Answer</span>
    <div id="render-Back" class="content-block answer-text"></div>

    <!-- 图片区域：强制作为 URL 处理 -->
    {{#image}}
    <div style="margin-top:20px; text-align:center;">
        <!-- {{text:image}} 会强制去除所有HTML格式，只留纯文本链接 -->
        <img src="{{text:image}}"
            style="max-width:100%; border-radius:12px; border:1px solid var(--line); box-shadow: 0 4px 12px rgba(0,0,0,0.1); display:inline-block;"
            onerror="this.style.display='none'">
    </div>
    {{/image}}
</div>

<!-- 4. 核心渲染脚本 -->
<script>
    var getResources = [
        getCSS("_katex.css", "https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"),
        getCSS("_highlight.css", "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/atom-one-dark.min.css"),
        getScript("_highlight.js", "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js"),
        getScript("_katex.min.js", "https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"),
        getScript("_auto-render.js", "https://cdn.jsdelivr.net/gh/Jwrede/Anki-KaTeX-Markdown/auto-render-cdn.js"),
        getScript("_markdown-it.min.js", "https://cdnjs.cloudflare.com/ajax/libs/markdown-it/12.0.4/markdown-it.min.js"),
        getScript("_markdown-it-mark.js", "https://cdn.jsdelivr.net/gh/Jwrede/Anki-KaTeX-Markdown/_markdown-it-mark.js")
    ];

    Promise.all(getResources)
        .then(() => getScript("_mhchem.js", "https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/mhchem.min.js"))
        .then(render)
        .catch(e => { console.error(e); fallback() });

    function render() {
        processField("raw-Front", "render-Front");
        processField("raw-Back", "render-Back");
        // 只对背面答案区域处理标签样式和列表符号
        processTags("render-Back");
        processListBullets("render-Back");
    }

    function fallback() {
        document.getElementById("render-Front").innerHTML = document.getElementById("raw-Front").innerHTML;
        document.getElementById("render-Back").innerHTML = document.getElementById("raw-Back").innerHTML;
    }

    function processField(sourceID, targetID) {
        let text = document.getElementById(sourceID).innerHTML;

        // 在清理 HTML 之前先处理 bullet 点，避免 <br> 被转换后丢失结构
        text = processBulletsInText(text);

        text = cleanAnkiHTML(text);

        let md = new markdownit({
            html: true,
            breaks: true,
            highlight: function (str, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try { return hljs.highlight(str, { language: lang }).value; } catch (__) { }
                }
                return '';
            }
        }).use(markdownItMark);

        let rendered = md.render(text);
        let target = document.getElementById(targetID);
        target.innerHTML = rendered;

        // 处理挖空语法 (cloze deletion)
        processCloze(target);

        renderMathInElement(target, {
            delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }],
            throwOnError: false
        });
    }

    // 挖空处理函数 - 点击显示/隐藏答案
    function processCloze(element) {
        let html = element.innerHTML;
        const clozeRegex = /\{\{c(\d+)::([^:}]+)(?:::([^}]+))?\}\}/g;
        html = html.replace(clozeRegex, function (match, num, text, hint) {
            return '<span class="cloze-toggle" onclick="this.classList.toggle(\'revealed\')">' + text + '</span>';
        });
        element.innerHTML = html;
    }

    // 处理 [文本] 格式的绿色标签
    function processTags(targetID) {
        let target = document.getElementById(targetID);
        let html = target.innerHTML;
        // 匹配 [文本] 格式，转换为带 tag 类的 span
        const tagRegex = /\[([^\]]+)\]/g;
        html = html.replace(tagRegex, function (match, content) {
            return '<span class="tag">' + content + '</span>';
        });
        target.innerHTML = html;
    }

    // 在原始文本中处理 bullet 点（支持 • 和 - 两种符号）
    function processBulletsInText(text) {
        // 匹配 • 或 - 开头的内容，包括被 <br> 或换行分隔的多行
        // 捕获从符号开始到下一个 <br> 或文本结束的内容
        const bulletRegex = /[•-]\s+([^<\n]+)/g;
        text = text.replace(bulletRegex, function (match, content) {
            return '<span class="bullet-item">' + content.trim() + '</span>';
        });
        return text;
    }

    // 处理 • 列表符号样式（用于渲染后的 HTML）
    function processListBullets(targetID) {
        let target = document.getElementById(targetID);

        // 处理所有包含 bullet 的元素（包括 <p>、<li>、<span> 等）
        const allElements = target.querySelectorAll('p, li, span, div');

        allElements.forEach(function (el) {
            let html = el.innerHTML;
            // 检查是否包含 bullet-item
            if (html.includes('bullet-item')) {
                el.classList.add('has-bullet');
            }
        });
    }

    function cleanAnkiHTML(str) {
        str = str.replace(/<[\/]?pre[^>]*>/gi, "");
        str = str.replace(/<br\s*[\/]?[^>]*>/gi, "\n");
        str = str.replace(/<div[^>]*>/gi, "\n");
        // 保留带 bullet-item 或 tag 类的 span，移除其他 span
        str = str.replace(/<span\s+(?!class=["']?(?:bullet-item|tag)["']?)[^>]*>|<\/span>/gi, "");
        str = str.replace(/<\/div[^>]*>/g, "\n");
        // 必须先替换 &，因为它会破坏其他实体的正确解码
        str = str.replace(/&/gi, "&");
        str = str.replace(/&nbsp;/gi, " ");
        str = str.replace(/&tab;/gi, "	");
        str = str.replace(/>/gi, ">");
        str = str.replace(/</gi, "<");
        return str;
    }

    function getScript(path, altURL) {
        return new Promise((resolve, reject) => {
            if (window[path]) return resolve();
            let script = document.createElement("script");
            script.onload = () => { window[path] = true; resolve(); };
            script.onerror = () => {
                let script_online = document.createElement("script");
                script_online.onload = () => { window[path] = true; resolve(); };
                script_online.onerror = resolve;
                script_online.src = altURL;
                document.head.appendChild(script_online);
            }
            script.src = path;
            document.head.appendChild(script);
        })
    }

    function getCSS(path, altURL) {
        return new Promise((resolve, reject) => {
            let css = document.createElement('link');
            css.rel = 'stylesheet';
            css.onload = resolve;
            css.onerror = () => {
                let css_online = document.createElement('link');
                css_online.rel = 'stylesheet';
                css_online.href = altURL;
                document.head.appendChild(css_online);
                resolve();
            }
            css.href = path;
            document.head.appendChild(css);
        });
    }
</script>